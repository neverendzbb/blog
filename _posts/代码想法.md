---
title: 代码记录
date: 2025-08-29 23:41:27
tags: [C++]

---

## 非递归中序遍历（统一迭代写法）

### 1.想法简介

这段代码用「空指针占位」技巧，把递归逻辑平铺到迭代里，思路非常巧妙：

### 遍历代码

``` cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ans;
        stack<TreeNode*> st;

        if (root) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top(); st.pop();
            if (!node) {                     // 空指针代表“回头”
                if (!st.empty()) {
                    ans.push_back(st.top()->val);
                    st.pop();
                }
                continue;
            }

            // 中序：右 -> 根 -> 左
            if (node->right) st.push(node->right);
            st.push(node);          // 根
            st.push(nullptr);       // 占位符：回头再输出根
            if (node->left) st.push(node->left);
        }
        return ans;
    }
};
```

## 并查集

### 2.问题

力扣 1971. 寻找图中是否存在路径

### 并查集代码

```cpp
class Solution {
public:
    vector<int>point;
    vector<int>math;
    int find(int x){
        if(point[x]==x){
            return x;
        }
        return point[x]=find(point[x]);
    }
    void unionset(int x,int y){
        int rootx=find(x);
        int rooty=find(y);
        if(rootx!=rooty){
            if(math[rootx]<=math[rooty]){
                point[rootx]=rooty;
                math[rooty]+=math[rootx];
            }
            else{
                point[rooty]=rootx;
                math[rootx]+=math[rooty];
            }
        }
    }
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        
        for(int i=0;i<n;i++){
            point.push_back(i);
            math.push_back(1);
        }
        for(int i=0;i<edges.size();i++){
            unionset(edges[i][0],edges[i][1]);
        }
        if(find(source)==find(destination))return true;
        return false;
    }
};
```

## 最小生成树

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct edge {
public:
    int from;
    int to;
    int w;
    edge(int f, int t, int w) {
        from = f;
        to = t;
        this->w = w;
    }
    bool operator<(const edge& e) const {
        return w < e.w;
    }
};

class mygraph {
public:
    int n;
    vector<vector<int>> g;
    vector<edge> e;
    void setg() {
        vector<edge> ee;
        vector<vector<int>> temg(n, vector<int>(n));
        int tem;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                cin >> tem;
                temg[i][j] = tem;
                if (tem != 0) {
                    edge teme(i, j, tem);
                    ee.push_back(teme);
                }
            }
        }
        g = temg;
        e = ee;
    }
    mygraph(int nn) : n(nn) {}
};

int find(vector<int>& p, int t) {
    if (p[t] == t) return t;
    return p[t] = find(p, p[t]);
}

void add(vector<int>& p, vector<int>& c, int a, int b) {
    int aa = find(p, a);
    int bb = find(p, b);
    if (aa == bb) {
        return;
    }
    if (c[aa] >= c[bb]) {
        p[bb] = aa;
        c[aa] += c[bb];
    } else {
        p[aa] = bb;
        c[bb] += c[aa];
    }
}

int kruskal2(vector<edge>& e, int n) { // 带并查集优化
    int sumw = 0;
    vector<int> v(n, 0);
    vector<int> count(n, 1);
    for (int i = 0; i < n; i++) {
        v[i] = i;
    }
    sort(e.begin(), e.end());
    int edge_cnt = 0;
    for (int i = 0; i < e.size(); i++) {
        int from = e[i].from;
        int to = e[i].to;
        if (find(v, from) != find(v, to)) {
            sumw += e[i].w;
            printf("添加从%d到%d权值为%d的路径\n", from + 1, to + 1, e[i].w);
            edge_cnt++;
            add(v, count, from, to);
        }
        if (edge_cnt == n - 1) {
            break;
        }
    }
    cout << sumw << endl;
    return sumw;
}

int kruskal1(vector<edge>& e, int n) {
    int sumw = 0;
    vector<int> v(n, 0);
    for (int i = 0; i < n; i++) {
        v[i] = i;
    }
    sort(e.begin(), e.end());
    int from;
    int to;
    int edge_cnt = 0;
    for (int i = 0; i < e.size(); i++) {
        from = e[i].from;
        to = e[i].to;
        int s1 = v[from];
        int s2 = v[to];
        if (s2 != s1) {
            sumw += e[i].w;
            printf("添加从%d到%d权值为%d的路径\n", from + 1, to + 1, e[i].w);
            edge_cnt++;
            cout << endl;
            for (int j = 0; j < n; j++) {
                if (v[j] == s2) {
                    v[j] = s1;
                }
            }
            if (edge_cnt == n - 1) break;
        }
    }
    cout << sumw << endl;
    return sumw;
}

int prim(const vector<vector<int>>& g, int n, int u) {
    int sum = 0;
    int min = 1000000;
    vector<int> v(n, 0);
    vector<int> pre(n, -1);
    v[u] = 1;
    int curto;
    int curfrom;
    int i, j, k;
    for (i = 0; i < n - 1; i++) {
        min = 1000000;
        curto = -1;
        curfrom = -1;
        for (j = 0; j < n; j++) {
            for (k = 0; k < n; k++) {
                if (v[j] == 1 && v[k] == 0 && g[j][k] < min && g[j][k] != 0) {
                    curto = k;
                    curfrom = j;
                    min = g[j][k];
                }
            }
        }
        if (curto == -1 || curfrom == -1) {
            cout << "图不连通，无法生成最小生成树" << endl;
            return -1;
        }
        v[curto] = 1;
        printf("%d->%d权值为%d", curfrom + 1, curto + 1, g[curfrom][curto]);
        cout << endl;
        pre[curto] = curfrom;
        sum += g[curfrom][curto];
    }
    cout << sum << endl;
    return sum;
}

int main() {
    int n;
    cin >> n;
    mygraph myg(n);
    myg.setg();
    prim(myg.g, n, 0);
    cout << endl;
    kruskal1(myg.e, n);
    kruskal2(myg.e, n);
    return 0;
}
```

## 二叉树层序遍历

### 4.问题

力扣102 二叉树的层序遍历
给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）

### 4.cpp

```cpp

/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*>myque;
        vector<vector<int>>ans;
        if(root==nullptr)return ans;
        myque.push(root);
        while(!myque.empty()){
            int curlevelsize=myque.size();
            vector<int>curlevel;
            for(int i=0;i<curlevelsize;i++){
                root=myque.front();
                curlevel.push_back(root->val);
                if(root->left)myque.push(root->left);
                if(root->right)myque.push(root->right);
                myque.pop();
            }
            ans.push_back(move(curlevel));//ans.push_back(move(curLevel));≈ “把当前层数据零拷贝地搬进结果数组。”
        }
        return ans;
    }
};
```

### 关于move函数

#### `ans.push_back(move(curLevel));` 做了什么？

- `move(curLevel)` 把 `curLevel` 这个 **左值** 转换成 **右值引用**；
- `push_back` 面对右值，会调用 `vector` 的 **移动构造函数**；
- 移动构造 **把 `curLevel` 内部的数据指针“搬”走**，变成 `ans` 的一个新元素；
- 搬完后，`curLevel` 被 **掏空（size = 0，指针为空）**，变成“空壳”；
- **原数据不能再使用**，但反正它马上就会被销毁，不影响程序。

#### 为什么变成空壳

- 不是 `move` 干的，是 **移动构造函数** 为了 **内存安全**；
- 防止两个 `vector` 同时管理同一块内存，避免 **重复释放**；
- 所以把原对象的指针设为 `nullptr`，让它变成“空壳”。

#### 总结一句话

- `move` 只是“打标签”让编译器选移动构造，真正“搬空”的是移动构造函数，搬完后原对象变成空壳，不能再读，但这里用完即弃，安全又高效。

## 堆排序

### 5.cpp

```cpp
#include<iostream>
#include<vector>
#include<random>
#include<ctime>
using namespace std;
void siftdown(vector<int>&R,int start,int end){
    int left=2*start+1;
    while(left<=end){
        if(left<end&&R[left]<R[left+1]){
            left++;
        }
        if(R[start]<R[left]){
            swap(R[start],R[left]);
            start=left;
            left=2*start+1;
        }
        else{
            break;
        }
    }
}
void siftdown2(vector<int>&R,int start,int end){
    int left=start*2+1;
    if(left>end)return;
    if(left<end&&R[left]<R[left+1]){
        left++;
    }
    if(R[start]<R[left]){
        swap(R[left],R[start]);
        siftdown2(R,left,end);
    }
}
void heapsort(vector<int>&R,int n){
    for(int i=n/2-1;i>=0;i--){
        siftdown2(R,i,n-1);
    }
    for(int i=n-1;i>0;i--){
        swap(R[0],R[i]);
        siftdown2(R,0,i-1);
    }
}
int main(){
    vector<int>a(10);
    srand(time(nullptr));
    for (int& x : a) x = rand() % 100;   // 100 以内
    for(const int tem:a)cout<<tem<<" ";
    cout<<endl;
    heapsort(a,10); 
    for(const int tem:a)cout<<tem<<" ";
    system("pause");
    return 0;
}
```

### 5.题目

### 力扣347. 前 K 个高频元素

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案

### 5.代码

```cpp
class Solution {
public:
    void siftdown(vector<int>& R, int start, int end) {
    int parent = start;
    int child = 2 * parent + 1;

    while (child <= end) {
        // 找到左右孩子中较大的那个
        if (child + 1 <= end && R[child] < R[child + 1]) {
            child++;
        }

        // 如果孩子比父节点大，交换并继续下沉
        if (R[child] > R[parent]) {
            swap(R[child], R[parent]);
            parent = child;
            child = 2 * parent + 1;
        } else {
            break;
        }
    }
}
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map <int,int>my;
        for(int tem:nums){
            my[tem]++;
        }
        vector<int>R;
        for(const auto[k,v]:my){
            R.push_back(v);
        }
        int n=R.size();
        for(int i=n/2-1;i>=0;i--){
            siftdown(R,i,n-1);
        }
        for(int i=n-1;i>=n-k;i--){
            swap(R[0],R[i]);
            siftdown(R,0,i-1);
        }
        vector<int>ans;
        for(int i=0;i<k;i++){
            for(auto it=my.begin();it!=my.end();it++){
                if(it->second==R[n-1-i]){ans.push_back(it->first);my.erase(it);break;}
            }
        }
        return ans;
    }
};
```

## 力扣949.腐烂的橘子

### 6.问题描述

在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：

值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。

返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。

示例 1：

输入：grid = [[2,1,1],[1,1,0],[0,1,1]]
输出：4
示例 2：

输入：grid = [[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。
示例 3：

输入：grid = [[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。

### 6.代码

```cpp

class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        queue<int>myqu;
        int id=0;
        int fresh=0;
        int n=grid.size();
        int m=grid[0].size();
        for(;id<n*m;id++){
            if(grid[id/m][id%m]==2){myqu.push(id);}
            else if(grid[id/m][id%m]==1){
                fresh++;
            }
        }
        int dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};
        int min=0;
        while(!myqu.empty()){
            bool finish=false;
            int curmath=myqu.size();
            for(int c=0;c<curmath;c++){
                int tem2=myqu.front();
                myqu.pop();
                int i=tem2/m;
                int j=tem2%m;
                for(int tem=0;tem<4;tem++){
                    int ni=i+dir[tem][0];
                    int nj=j+dir[tem][1];
                    if(ni>=0&&ni<n&&nj>=0&&nj<m&&grid[ni][nj]==1){
                        myqu.push(ni*m+nj);
                        grid[ni][nj]=2;
                        fresh--;
                        finish=true;
                    }
                }
            }
            if(finish)min++;
        }
        if(fresh==0)
        return min;
        return -1;
    }
};
```
